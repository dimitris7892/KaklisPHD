import numpy as np
import dataModeling as dt
import tensorflow as tf
import sklearn.ensemble as skl
import statsmodels.api
#from statsmodels.formula.api import ols
import pandas as pd
#import scikit_posthocs as sp
from scipy import stats
from scipy.interpolate import BPoly as Bernstein
from itertools import combinations
from statsmodels.stats.multitest import multipletests
import warnings
import math
from scipy import spatial
import pyearth as sp
from scipy.spatial import Delaunay, ConvexHull
import matplotlib.pyplot as plt
import csv
import pyearth as sp
import sklearn.svm as svr
import latex
from matplotlib import rc



class Evaluation:
    def evaluate(self, train, unseen, model,genericModel):
        return 0.0

class MeanAbsoluteErrorEvaluation (Evaluation):
    '''
    Performs evaluation of the datam returning:
    errors: the list of errors over all instances
    meanError: the mean of the prediction error
    sdError: standard deviation of the error
    '''
    def evaluate(self, unseenX, unseenY, modeler,genericModel):
        lErrors = []
        for iCnt in range(np.shape(unseenX)[0]):
            pPoint = unseenX[iCnt].reshape(1, -1)#[0] # Convert to matrix
            trueVal = unseenY[iCnt]
            prediction = modeler.getBestModelForPoint(pPoint).predict(pPoint)

            lErrors.append(abs(prediction - trueVal))
        errors = np.asarray(lErrors)

        return errors, np.mean(errors), np.std(lErrors)

    def evaluateNN(self, unseenX, unseenY, modeler,output,xs):
        lErrors = []
        self.session = tf.Session()
        saver = tf.train.Saver()
       # tf.saved_model.loader.load(
       #     self.session,
       #     [ tf.saved_model.tag_constants.TRAINING ],
       #     './save')

        for iCnt in range(np.shape(unseenX)[0]):

            saver.restore(self.session, "./save/test_" + str(iCnt) + ".ckpt")
            model = modeler.getBestModelForPoint(pPoint)
            pPoint = unseenX[iCnt].reshape(1, -1)#[0] # Convert to matrix
            trueVal = unseenY[iCnt]
            prediction = self.session.run(output, feed_dict={xs: pPoint})
            lErrors.append(abs(prediction - trueVal))
            errors = np.asarray(lErrors)

        return errors, np.mean(errors), np.std(lErrors)


    def evaluateKerasNN1(self, unseenX, unseenY, modeler,output,xs,genericModel,partitionsX , scores):
        lErrors = []

        from tensorflow import keras
        path = '.\\'
        clusters = '30'

        count = 0
        errorStwArr=[]
        for iCnt in range(np.shape(unseenX)[0]):
            pPoint =unseenX[iCnt]
            pPoint= pPoint.reshape(-1,unseenX.shape[1])

            trueVal = unseenY[iCnt]

            ind, fit = modeler.getBestPartitionForPoint(pPoint, partitionsX)

            #pred=0
            #for i in range(0,len(partitionsX)):
                #pred +=modeler._models[i].predict(pPoint)
            #prediction = pred / len(partitionsX)
            vector = self.extractFunctionsFromSplines(pPoint[0][0], pPoint[0][1],pPoint[0][2],pPoint[0][3],pPoint[0][4],pPoint[0][5],pPoint[0][6], ind)
            XSplineVector = np.append(pPoint, vector)
            XSplineVector = XSplineVector.reshape(-1, XSplineVector.shape[0])

            vector = self.extractFunctionsFromSplines(pPoint[0][0], pPoint[0][1],pPoint[0][2],pPoint[0][3],pPoint[0][4],pPoint[0][5],pPoint[0][6], 'Gen')
            XSplineGenVector = np.append(pPoint, vector)
            XSplineGenVector = XSplineGenVector.reshape(-1, XSplineGenVector.shape[0])
            # prediction = abs(modeler._models[ 0 ].predict(XSplineVector))
            # XSplineVector = XSplineGenVector if modeler._models[ind][1]=='GEN' else XSplineVector
            # prediction = (abs(modeler._models[ind].predict(XSplineVector)) + modeler._models[len(modeler._models)-1].predict(XSplineGenVector))/2
            prediction = (abs(modeler._models[ind].predict(XSplineVector)) + modeler._models[
                len(modeler._models) - 1].predict(XSplineGenVector)) / 2

            #prediction = (abs(modeler._models[ind].predict(pPoint)))
            #prediction =  modeler._models[len(modeler._models) - 1].predict(pPoint)
            #prediction = (abs(modeler._models[ind].predict(pPoint)) + modeler._models[len(modeler._models) - 1].predict(pPoint) )/ 2
            error = abs(prediction - trueVal)
            lErrors.append(error)

            errorStwArr.append(np.array(np.append(np.asmatrix(pPoint[0][0]).reshape(-1,1), np.asmatrix([error[0]]).T, axis=1)))



        errorStwArr = np.array(errorStwArr)
        errorStwArr = errorStwArr.reshape(-1, 2)
        errors = np.asarray(lErrors)
        with open('./errorSTW'+str(len(partitionsX))+'.csv', mode='w') as data:
            data_writer = csv.writer(data, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
            data_writer.writerow(
                ['STW', 'MAE'])
            for i in range(0, len(errorStwArr)):
                data_writer.writerow(
                    [errorStwArr[i][0],errorStwArr[i][1]])

        #plt.scatter(errorStwArr[:,0],errorStwArr[:,1])
        #plt.ylim(0, 2)
        #plt.title('Model loss with ' + str(1) + ' cluster(s)')
        #plt.ylabel('MAE')
        #plt.xlabel('STW')
        #plt.show()
        x = 0

        return errors, np.mean(errors), np.std(lErrors)

    def evaluateKerasNN(self, unseenX, unseenY, modeler,output,xs,genericModel,partitionsX , scores):
        lErrors = []

        for iCnt in range(np.shape(unseenX)[0]):
            pPoint =unseenX[iCnt]
            pPoint= pPoint.reshape(-1,unseenX.shape[1])


            trueVal = unseenY[iCnt]

            ind, fit = modeler.getBestPartitionForPoint(pPoint, partitionsX)
            prediction = (abs(modeler._models[ind].predict(pPoint)) + modeler._models[len(modeler._models) - 1].predict(
                pPoint)) / 2
            lErrors.append(abs(prediction - trueVal))

        errors = np.asarray(lErrors)

        return errors, np.mean(errors), np.std(lErrors)

    def extractFunctionsFromSplines(self,x0, x1, x2, x3, x4, x5, x6,modelId):
        piecewiseFunc = []
        csvModels=['./model_'+str(modelId)+'_.csv']
        for csvM in csvModels:
            if csvM != './model_' + str(modelId) + '_.csv':
                continue
            # id = csvM.split("_")[ 1 ]
            # piecewiseFunc = [ ]

            with open(csvM) as csv_file:
                data = csv.reader(csv_file, delimiter=',')
                for row in data:
                    # for d in row:
                    if [w for w in row if w == "Basis"].__len__() > 0:
                        continue
                    if [w for w in row if w == "(Intercept)"].__len__() > 0:
                        self.interceptsGen = float(row[1])
                        continue

                    if row.__len__() == 0:
                        continue
                    d = row[0]
                    #if self.count == 1:
                        #self.intercepts.append(float(row[1]))

                    if d.split("*").__len__() == 1:
                        split = ""
                        try:
                            split = d.split('-')[0][2:3]
                            if split != "x":
                                split = d.split('-')[1]
                                num = float(d.split('-')[0].split('h(')[1])
                                # if id == id:
                                # if float(row[ 1 ]) < 10000:
                                try:
                                    # piecewiseFunc.append(
                                    # tf.math.multiply(tf.cast(tf.math.less(x, num), tf.float32),
                                    # (num - inputs)))
                                    if split.__contains__("x0"):
                                        piecewiseFunc.append((num - x0))  # * float(row[ 1 ]))
                                    if split.__contains__("x1"):
                                        piecewiseFunc.append((num - x1))  # * float(row[ 1 ]))
                                    if split.__contains__("x2"):
                                        piecewiseFunc.append((num - x2))  # * float(row[ 1 ]))
                                    if split.__contains__("x3"):
                                        piecewiseFunc.append((num - x3))  # * float(row[ 1 ]))
                                    if split.__contains__("x4"):
                                        piecewiseFunc.append((num - x4))  # * float(row[ 1 ]))
                                    if split.__contains__("x5"):
                                        piecewiseFunc.append((num - x5))  # * float(row[ 1 ]))
                                    if split.__contains__("x6"):
                                        piecewiseFunc.append((num - x6))  # * float(row[ 1 ]))
                                # if id ==  self.modelId:
                                # inputs = tf.where(x >= num, float(row[ 1 ]) * (inputs - num), inputs)
                                except:
                                    dc = 0
                            else:
                                ##x0 or x1
                                split = d.split('-')[0]
                                num = float(d.split('-')[1].split(')')[0])
                                # if id == id:
                                # if float(row[ 1 ]) < 10000:
                                try:
                                    if split.__contains__("x0"):
                                        piecewiseFunc.append((x0 - num))  # * float(row[ 1 ]))
                                    if split.__contains__("x1"):
                                        piecewiseFunc.append((x1 - num))  # * float(row[ 1 ]))
                                    if split.__contains__("x2"):
                                        piecewiseFunc.append((x2 - num))  # * float(row[ 1 ]))
                                    if split.__contains__("x3"):
                                        piecewiseFunc.append((x3 - num))  # * float(row[ 1 ]))
                                    if split.__contains__("x4"):
                                        piecewiseFunc.append((x4 - num))  # * float(row[ 1 ]))
                                    if split.__contains__("x5"):
                                        piecewiseFunc.append((x5 - num))  # * float(row[ 1 ]))
                                    if split.__contains__("x6"):
                                        piecewiseFunc.append((x6 - num))  # * float(row[ 1 ]))

                                    # piecewiseFunc.append(
                                    # tf.math.multiply(tf.cast(tf.math.greater(x, num), tf.float32),
                                    # (inputs - num)))
                                # if id == self.modelId:
                                # inputs = tf.where(x <= num, float(row[ 1 ]) * (num - inputs), inputs)
                                except:
                                    dc = 0
                        except:
                            # if id == id:
                            # if float(row[ 1 ]) < 10000:
                            try:
                                piecewiseFunc.append(x0)

                                # piecewiseFunc.append(tf.math.multiply(tf.cast(x, tf.float32),
                                # (inputs)))

                                # inputs = tf.where(x >= 0, float(row[ 1 ]) * inputs, inputs)
                            # continue
                            except:
                                dc = 0

                    else:
                        funcs = d.split("*")
                        nums = []
                        flgFirstx = False
                        flgs = []
                        for r in funcs:
                            try:
                                if r.split('-')[0][2] != "x":
                                    flgFirstx = True
                                    nums.append(float(r.split('-')[0].split('h(')[1]))

                                else:
                                    nums.append(float(r.split('-')[1].split(')')[0]))

                                flgs.append(flgFirstx)
                            except:
                                flgFirstx = False
                                flgs = []
                                split = d.split('-')[0][2]
                                try:
                                    if d.split('-')[0][2] == "x":
                                        # if id == id:
                                        # if float(row[ 1 ]) < 10000:
                                        try:

                                            if d.split("-")[0].__contains__("x1") and d.split("-")[1].__contains__(
                                                    "x1"):
                                                split = "x1"
                                            if d.split("-")[0].__contains__("x0") and d.split("-")[1].__contains__(
                                                    "x0"):
                                                split = "x0"
                                            if d.split("-")[0].__contains__("x0") and d.split("-")[1].__contains__(
                                                    "x1"):
                                                split = "x01"
                                            if d.split("-")[0].__contains__("x1") and d.split("-")[1].__contains__(
                                                    "x0"):
                                                split = "x10"

                                            if split == "x0":
                                                piecewiseFunc.append(x0 * (x0 - nums[0]) * float(row[1]))
                                            elif split == "x1":
                                                piecewiseFunc.append(x1 * (x1 - nums[0]) * float(row[1]))
                                            elif split == "x01":
                                                piecewiseFunc.append(x0 * (x1 - nums[0]) * float(row[1]))
                                            elif split == "x10":
                                                piecewiseFunc.append(x1 * (x0 - nums[0]) * float(row[1]))
                                            # piecewiseFunc.append(tf.math.multiply(tf.cast(x, tf.float32),
                                            # (inputs) * (
                                            # inputs - nums[ 0 ])))

                                            # inputs = tf.where(x >= 0,
                                            # float(row[ 1 ]) * (inputs) * (inputs - nums[ 0 ]), inputs)
                                        except:
                                            dc = 0

                                    else:
                                        flgFirstx = True
                                        # if id == id:
                                        # if float(row[ 1 ]) < 10000:
                                        try:

                                            if d.split("-")[0].__contains__("x1") and d.split("-")[
                                                1].__contains__("x1"):
                                                split = "x1"
                                            if d.split("-")[0].__contains__("x0") and d.split("-")[
                                                1].__contains__("x0"):
                                                split = "x0"
                                            if d.split("-")[0].__contains__("x0") and d.split("-")[
                                                1].__contains__("x1"):
                                                split = "x01"
                                            if d.split("-")[0].__contains__("x1") and d.split("-")[
                                                1].__contains__("x0"):
                                                split = "x10"

                                            if split == "x0":
                                                piecewiseFunc.append(x0 * (nums[0] - x0) * float(row[1]))
                                            elif split == "x1":
                                                piecewiseFunc.append(x1 * (nums[0] - x1) * float(row[1]))
                                            elif split == "x01":
                                                piecewiseFunc.append(x0 * (nums[0] - x1) * float(row[1]))
                                            elif split == "x10":
                                                piecewiseFunc.append(x1 * (nums[0] - x0) * float(row[1]))

                                            # piecewiseFunc.append(tf.math.multiply(tf.cast(x, tf.float32),
                                            # (inputs) * (
                                            # nums[ 0 ] - inputs)))

                                            # inputs = tf.where(x > 0 ,
                                            # float(row[ 1 ]) * (inputs) * (nums[ 0 ] - inputs),inputs)
                                            flgs.append(flgFirstx)
                                        except:
                                            dc = 0

                                except:
                                    # if id == id:
                                    # if float(row[ 1 ]) < 10000:
                                    try:
                                        piecewiseFunc.append(x0)

                                        # piecewiseFunc.append(tf.math.multiply(tf.cast(x, tf.float32),
                                        # (inputs)))

                                        # inputs = tf.where(x >= 0, float(row[ 1 ]) * (inputs), inputs)
                                    except:
                                        dc = 0
                        try:
                            # if id == id:
                            if flgs.count(True) == 2:
                                # if float(row[ 1 ])<10000:
                                try:

                                    if d.split("-")[0].__contains__("x1") and d.split("-")[1].__contains__(
                                            "x1"):
                                        split = "x1"
                                    if d.split("-")[0].__contains__("x0") and d.split("-")[1].__contains__(
                                            "x0"):
                                        split = "x0"
                                    if d.split("-")[0].__contains__("x0") and d.split("-")[1].__contains__(
                                            "x1"):
                                        split = "x01"
                                    if d.split("-")[0].__contains__("x1") and d.split("-")[1].__contains__(
                                            "x0"):
                                        split = "x10"

                                    if split == "x0":
                                        piecewiseFunc.append((nums[0] - x0) * (nums[1] - x0) * float(row[1]))
                                    elif split == "x1":
                                        piecewiseFunc.append((nums[0] - x1) * (nums[1] - x1) * float(row[1]))
                                    elif split == "x01":
                                        piecewiseFunc.append((nums[0] - x0) * (nums[1] - x1) * float(row[1]))
                                    elif split == "x10":
                                        piecewiseFunc.append((nums[0] - x1) * (nums[1] - x0) * float(row[1]))

                                    # piecewiseFunc.append(tf.math.multiply(tf.cast(
                                    # tf.math.logical_and(tf.math.less(x, nums[ 0 ]),
                                    # tf.math.less(x, nums[ 1 ])), tf.float32),
                                    # (nums[ 0 ] - inputs) * (
                                    # nums[ 1 ] - inputs)))

                                    # inputs = tf.where(x < nums[0] and x < nums[1],
                                    # float(row[ 1 ]) * (nums[ 0 ] - inputs) * (
                                    # nums[ 1 ] - inputs), inputs)
                                except:
                                    dc = 0

                            elif flgs.count(False) == 2:
                                # if float(row[ 1 ]) < 10000:
                                try:
                                    if d.split("-")[0].__contains__("x1") and d.split("-")[1].__contains__(
                                            "x1"):
                                        split = "x1"
                                    if d.split("-")[0].__contains__("x0") and d.split("-")[1].__contains__(
                                            "x0"):
                                        split = "x0"
                                    if d.split("-")[0].__contains__("x0") and d.split("-")[1].__contains__(
                                            "x1"):
                                        split = "x01"
                                    if d.split("-")[0].__contains__("x1") and d.split("-")[1].__contains__(
                                            "x0"):
                                        split = "x10"

                                    if split == "x0":
                                        piecewiseFunc.append((x0 - nums[0]) * (x0 - nums[1]) * float(row[1]))
                                    elif split == "x1":
                                        piecewiseFunc.append((x1 - nums[0]) * (x1 - nums[1]) * float(row[1]))
                                    elif split == "x01":
                                        piecewiseFunc.append((x0 - nums[0]) * (x1 - nums[1]) * float(row[1]))
                                    elif split == "x10":
                                        piecewiseFunc.append((x1 - nums[0]) * (x0 - nums[1]) * float(row[1]))
                                    # inputs = tf.where(x > nums[ 0 ] and x > nums[ 1 ],
                                    # float(row[ 1 ]) * (inputs - nums[ 0 ]) * (
                                    # inputs - nums[ 1 ]), inputs)
                                except:
                                    dc = 0
                            else:
                                try:
                                    if flgs[0] == False:
                                        if nums.__len__() > 1:
                                            # if float(row[ 1 ]) < 10000:
                                            try:
                                                if d.split("-")[0].__contains__("x1") and d.split("-")[
                                                    2].__contains__("x1"):
                                                    split = "x1"
                                                if d.split("-")[0].__contains__("x0") and d.split("-")[
                                                    2].__contains__("x0"):
                                                    split = "x0"
                                                if d.split("-")[0].__contains__("x0") and d.split("-")[
                                                    2].__contains__("x1"):
                                                    split = "x01"
                                                if d.split("-")[0].__contains__("x1") and d.split("-")[
                                                    2].__contains__("x0"):
                                                    split = "x10"

                                                if split == "x0":
                                                    piecewiseFunc.append(
                                                        (x0 - nums[0]) * (nums[1] - x0) * float(row[1]))
                                                elif split == "x1":
                                                    piecewiseFunc.append(
                                                        (x1 - nums[0]) * (nums[1] - x1) * float(row[1]))
                                                elif split == "x01":
                                                    piecewiseFunc.append(
                                                        (x0 - nums[0]) * (nums[1] - x1) * float(row[1]))
                                                elif split == "x10":
                                                    piecewiseFunc.append(
                                                        (x1 - nums[0]) * (nums[1] - x0) * float(row[1]))




                                            # inputs = tf.where(x > nums[ 0 ] and x < nums[ 1 ],
                                            # float(row[ 1 ]) * (inputs - nums[ 0 ]) * (
                                            # nums[ 1 ] - inputs), inputs)
                                            except:
                                                dc = 0
                                        else:
                                            # if float(row[ 1 ]) < 10000:
                                            try:
                                                if d.split("-")[0].__contains__("x1") and d.split("-")[
                                                    1].__contains__("x1"):
                                                    split = "x1"
                                                if d.split("-")[0].__contains__("x0") and d.split("-")[
                                                    1].__contains__("x0"):
                                                    split = "x0"
                                                if d.split("-")[0].__contains__("x0") and d.split("-")[
                                                    1].__contains__("x1"):
                                                    split = "x01"
                                                if d.split("-")[0].__contains__("x1") and d.split("-")[
                                                    1].__contains__("x0"):
                                                    split = "x10"

                                                piecewiseFunc.append((x0 - nums[0]) * float(row[1]))

                                                # inputs = tf.where(x > nums[0],
                                                # float(row[ 1 ]) * (inputs - nums[ 0 ]), inputs)
                                            except:
                                                dc = 0
                                    else:
                                        if nums.__len__() > 1:
                                            # if float(row[ 1 ]) < 10000:
                                            try:
                                                if d.split("-")[0].__contains__("x1") and d.split("-")[
                                                    1].__contains__("x1"):
                                                    split = "x1"
                                                if d.split("-")[0].__contains__("x0") and d.split("-")[
                                                    1].__contains__("x0"):
                                                    split = "x0"
                                                if d.split("-")[0].__contains__("x0") and d.split("-")[
                                                    1].__contains__("x1"):
                                                    split = "x01"
                                                if d.split("-")[0].__contains__("x1") and d.split("-")[
                                                    1].__contains__("x0"):
                                                    split = "x10"

                                                if split == "x0":
                                                    piecewiseFunc.append(
                                                        (nums[0] - x0) * (x0 - nums[1]) * float(row[1]))
                                                elif split == "x1":
                                                    piecewiseFunc.append(
                                                        (nums[0] - x1) * (x1 - nums[1]) * float(row[1]))
                                                elif split == "x01":
                                                    piecewiseFunc.append(
                                                        (nums[0] - x0) * (x1 - nums[1]) * float(row[1]))
                                                elif split == "x10":
                                                    piecewiseFunc.append(
                                                        (nums[0] - x1) * (x0 - nums[1]) * float(row[1]))
                                                # inputs = tf.where(x < nums[ 0 ] and x > nums[1],
                                                # float(row[ 1 ]) * (nums[ 0 ] - inputs) * (
                                                # inputs - nums[ 1 ]), inputs)
                                            except:
                                                dc = 0
                                        else:
                                            # if float(row[ 1 ]) < 10000:
                                            try:

                                                if d.split("-")[0].__contains__("x1") and d.split("-")[
                                                    1].__contains__("x1"):
                                                    split = "x1"
                                                if d.split("-")[0].__contains__("x0") and d.split("-")[
                                                    1].__contains__("x0"):
                                                    split = "x0"
                                                if d.split("-")[0].__contains__("x0") and d.split("-")[
                                                    1].__contains__("x1"):
                                                    split = "x01"
                                                if d.split("-")[0].__contains__("x1") and d.split("-")[
                                                    1].__contains__("x0"):
                                                    split = "x10"

                                                if split == "x0":
                                                    piecewiseFunc.append((x0 - nums[0]) * float(row[1]))
                                                elif split == "x1":
                                                    piecewiseFunc.append((x1 - nums[0]) * float(row[1]))
                                                # piecewiseFunc.append(tf.math.multiply(tf.cast(
                                                # tf.math.less(x, nums[ 0 ]), tf.float32),
                                                # (
                                                # inputs - nums[ 0 ])))

                                                # inputs = tf.where(x < nums[ 0 ],
                                                # float(row[ 1 ]) * (
                                                # inputs - nums[ 0 ]), inputs)
                                            except:
                                                dc = 0
                                except:
                                    dc = 0
                        except:
                            dc = 0

        return piecewiseFunc

    def ANOVAtest(self,clusters,var,error,models,partitioners):

        df = pd.DataFrame({
                            'clusters': clusters,
                            'var': var,
                            'error':error,
                            'partitioners':partitioners,
                            'models':models
                            #'meanBearing':trFeatures[1]
                            })
        groups=[error,clusters,var]


        #data=[error,np.var(unseenX),clusters]
        print(stats.kruskal(error,clusters,var,models,partitioners))
        #print(self.kw_dunn(groups,[(0,1),(0,2)]))

        #dataf = pd.DataFrame.from_dict(df, orient='index')
        df.to_csv('./NEWres_1.csv', index=False)
        #df.melt(var_name='groups', value_name='values')
        df=pd.melt(df,var_name='groups', value_name='values')
        print(df)
        #df2=sp.posthoc_dunn(df, val_col='values', group_col='groups')
        #df2.to_csv('./kruskal.csv', index=False)
        #print(df2)


        #formula = 'error ~ C(clusters) + C(var) + C(error)'
        ##model =  ols(formula, df).fit()
        #aov_table = statsmodels.stats.anova.anova_lm(model, typ=2)
        #print(aov_table)
